#'
#' Nested MGKS effects for mgcv
#'
#' This function implements the nested Multivariate Gaussian Kernel Smoothing (MGKS) effects. 
#' MGKS is designed to handle spatially misaligned data by smoothing observations at distinct 
#' locations using their pairwise distances. 
#' The \code{mgks} is formally defined as follows. Let \eqn{{z}_{ij}} represent a scalar covariate associated with the vector \eqn{{x}_{ij}}. For example, \eqn{{z}_{ij}} could represent the temperature at time \eqn{i}, while \eqn{{x}_{ij}} might indicate the longitude and latitude of the observation location.  
#'  
#' The kernel smoothing estimation of \eqn{z_i} at position \eqn{{x}_i} is computed as:  
#' \deqn{s~({x}_i) = \frac{\sum_{j=1}^{n_j}K_{{a}}({x}_{i}, {{x}}_{ij})z_{ij}}{\sum_{q=1}^{n_j}K_{{a}}({x}_{i},{{x}}_{iq})},}  
#' where \eqn{K_{a}} is a kernel function from a multivariate probability density, parameterized by the vector \eqn{{a}}.  
#'  
#' In general \eqn{{x}_i} does not necessarily belong to the set \eqn{({x}_{i1}, \ldots, {x}_{in_j})}. This flexibility of \eqn{s~} makes it especially useful in cases of misaligned covariates, where the covariate measurements are taken at locations different from the sites of the response variable.  
#'
#' @param object A \code{smooth.spec} object containing details about the smooth term generated by a term \code{s_nest(...)}. 
#' It includes distance matrices and response variables.
#' @param data A data frame containing variables required for smoothing, including:
#' \itemize{
#'   \item \code{y}: Response variable to be smoothed.
#'   \item \code{d}: Pairwise distance matrices.
#' }
#' @param knots A list specifying knots for constructing the outer B-spline basis.
#'
#' @return A \code{"mgks"} and \code{"nested"} object.
#'
#' @examples 
#' n0 <- 50;n <- 1000
#' X0 <- cbind(runif(n0, -1, 1), runif(n0, -4, 4))
#' X <- cbind(runif(n, -1, 1), runif(n, -4, 4))
#' dist <- lapply(1:ncol(X), function(dd){
#'   t(sapply(1:nrow(X), function(ii) (X[ii, dd] - X0[ , dd])^2 ))
#' })
#' dist <- dist[[1]] + dist[[2]]
#' trueF <- function(x) 3 * x[ , 1] + x[ , 2]^2
#' temp <- t(sapply(1:n, function(ii) trueF(X0)))
#' 
#' z.mgks <- trueF(X)
#' dat <- data.frame(y = z.mgks*cos(z.mgks/2)+rnorm(n))
#' dat$Xks <- cbind(temp,dist)
#' colnames(dat$Xks) <- c(rep("y", nrow(X0)), rep("d1", nrow(X0)))
#' aaa <- smoothCon(s_nest(Xks, trans=trans_mgks(), m = c(4, 2)),data = dat)
#'
#' @seealso \code{\link{mgks}, \code{\link{trans_mgks}}}
#'
#' @name smooth.construct.mgks.smooth.spec
#' @rdname smooth.construct.mgks.smooth.spec
#' @importFrom mgcv smooth.construct Predict.matrix.Bspline.smooth sdiag bandchol psum.chisq
#' @importFrom stats cov
#' @export
#' 
smooth.construct.mgks.smooth.spec <- function(object, data, knots)
{ 
  si <- object$xt$si
  
  # We have n0 original locations (one on each row of X0) and corresponding observations in y0
  Xi <- data[[object$term]]
  n <- nrow( Xi )
  nms <- colnames(Xi)
  y0 <- Xi[ , which(nms == "y"), drop = FALSE]
  if( !ncol(y0) ){
    y0 <- si$y0
  }
  Dist <- list()
  kk <- 1
  while( TRUE ){
    idx <- which(startsWith(nms, "d") & endsWith(nms, as.character(kk)) & sapply(nms, function(.x) nchar(.x) == 2))
    if( !length(idx) ){
      break
    }
    Dist[[kk]] <- Xi[ , idx, drop = FALSE]
    kk <- kk + 1
  }
  d <- kk
  
  si$x <- y0
  si$dist <- Dist
  
  # Need to initialize inner coefficients?
  alpha <- si$alpha
  if( is.null(alpha) ){ 
    # alpha[1] s.t. sd(inner_lin_pred) = 1 (target variance)
    # Other elements of alpha set to the negative marginal standard deviations / 10.
    # Dividing by 10 seems a good compromise between under- and over-smoothing.
    g <- mgks(y = si$x, dist = Dist, beta = -log(sapply(si$dist, sd)/10))$d0
    alpha <- si$alpha <- c(log(1/sd(g)), -log(sapply(si$dist, sd)/10)) 
  } else {
    g <- mgks(y = si$x, dist = Dist, beta = alpha)$d0
    alpha <- si$alpha <- c(log(1/sd(g)), alpha)
  }
  
  # Center and scale the initialized inner linear preditor
  data[[object$term]] <- exp(si$alpha[1]) * (g - mean(g))
  
  out <- .build_nested_bspline_basis(object = object, data = data, knots = knots, si = si)
  
  class(out) <- c("mgks", "nested")
  return( out )
} 

