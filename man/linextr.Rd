% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/linextr.R
\name{linextr}
\alias{linextr}
\title{Linearly extrapolates a univariate spline basis}
\usage{
linextr(x, b, th, Xbo, Xbo1, method = "smooth", r = NULL)
}
\arguments{
\item{x}{the vector of points at which basis is evaluated.}

\item{b}{a list where \code{b[[1]]} contains the basis evaluated at x,
\code{b[[2]]} the matrix of first derivatives (w.r.t. x) and so on.}

\item{th}{the two boundaries beyond which the linear extrapolation occurs.}

\item{Xbo}{a 2 x p matrix, where p is the number of basis functions. It contains
the basis functions evaluated at \code{th[1]} and \code{th[2]}.}

\item{Xbo1}{same as \code{Xbo} but this is the first derivative of the
basis functions.}

\item{method}{if set to \code{"simple"}, derivatives of order >= 2 are set to 0 outside of
\code{range(th)}. If set to \code{"smooth"} higher derivatives
decay to zero exponentially at rate r, as we move away from
(\code{th[1]},\code{th[2]}).}
}
\value{
A list where \code{b[[1]]} contains the linearly extrapolated
basis functions evaluated at \code{x}, \code{b[[2]]} the matrix of
first derivatives (w.r.t. x) evaluated at \code{x}, and so on.
}
\description{
Linearly extrapolates a univariate spline basis
}
\examples{
library(gamFactory)

# Set up basis
xseq <- seq(-4, 4, length.out = 1e3) 
k <- 20
m <- 4
ko <- k + m + 2
knots <- qunif((1:ko)/(ko+1), -5, 5)

mybasis <- basis_bspline(knots = knots, m = m) 

# Evaluate design matrix and derivatives 
X <- basis_bspline(knots = knots, m = m)$evalX(x = xseq, deriv = 3)

# Get limits of "inner" knots and derivatives of basis at the extremal knots
krange <- mybasis$krange
X_th <- basis_bspline(knots = knots, m = m)$evalX(x = krange, deriv = 4)

# Linearise basis beyond krange
X_ext1 <- linextr(x = xseq, b = X, th = krange, 
                  Xbo = X_th$X0, Xbo1 = X_th$X1, method = "simple")

# Smoothly linearise basis beyond krange
X_ext2 <- linextr(x = xseq, b = X, th = krange, 
                  Xbo = X_th$X0, Xbo1 = X_th$X1, method = "smooth")

# Plot effect with random coefficients
betas <- runif(ncol(X$X0))
par(mfrow = c(1, 1))
plot(xseq, X_ext1$X0\%*\%betas, type = 'l', col = 1) # Linearly extrapolated
lines(xseq, X_ext2$X0\%*\%betas, type = 'l', col = 4)# Smoothly linearly extrap
lines(xseq, X$X0\%*\%betas, col = 2)                 # Original
abline(v = krange[1], lty = 2)
abline(v = krange[2], lty = 2)

# Above we see some small bumps just beyond krange (look at discrepancy
# between blue and red, you might to run this a few times to see it).
# We can reduce this by setting to zero a few derivatives of order > 1 
# at krange. For i = 1 and 2, below we impose that
# f''(krange[i]) = f'''(krange[i]) = f''''(krange[i]) =  0  

# We first constrain the original basis by reparametrising it
library(MASS)
NS <- Null( t(rbind(X_th$X2, X_th$X3, X_th$X4)) )
X_con <- X
X_con$X0 <- X$X0 \%*\% NS
X_con$X1 <- X$X1 \%*\% NS
X_con$X2 <- X$X2 \%*\% NS
X_con$X3 <- X$X3 \%*\% NS

# Linearise reparametrised basis beyond krange
X_ext1 <- linextr(x = xseq, b = X_con, th = krange, 
                  Xbo = X_th$X0\%*\%NS, Xbo1 = X_th$X1\%*\%NS, method = "simple")

# Smoothly linearise basis beyond krange
X_ext2 <- linextr(x = xseq, b = X_con, th = krange, 
                  Xbo = X_th$X0\%*\%NS, Xbo1 = X_th$X1\%*\%NS, method = "smooth")

# Plot effect with random coefficients
betas <- runif(ncol(X_con$X0))
par(mfrow = c(1, 1))
plot(xseq, X_ext1$X0\%*\%betas, type = 'l', col = 1) #Linearly extrapolated
lines(xseq, X_ext2$X0\%*\%betas, type = 'l', col = 4)#Smoothly linearly extrap
lines(xseq, X_con$X0\%*\%betas, col = 2)             #Original (reparametrised)
# No appreciable difference between standard (black) and smooth (blue)
# extrapolation

# Checking whether the derivatives of the extrapolated basis are right
wrap_basis <- function(x){
  X <- basis_bspline(knots = knots, m = m)$evalX(x = x, deriv = 3)
  X$X0 <- X$X0 \%*\% NS
  X$X1 <- X$X1 \%*\% NS
  X$X2 <- X$X2 \%*\% NS
  X$X3 <- X$X3 \%*\% NS
  X <- linextr(x = x, b = X, th = krange, 
               Xbo = X_th$X0\%*\%NS, Xbo1 = X_th$X1\%*\%NS, method = "smooth")
  return(X) 
}

l0 <- wrap_basis(x = xseq)
lm <- wrap_basis(x = xseq - 1e-5)
lp <- wrap_basis(x = xseq + 1e-5)

# It seems so!
par(mfrow = c(2, 2))
plot(l0$X1, (lp$X0 - lm$X0) / 2e-5)
abline(0, 1, col = 2)
plot(l0$X2, (lp$X1 - lm$X1) / 2e-5)
abline(0, 1, col = 2)
plot(l0$X3, (lp$X2 - lm$X2) / 2e-5)
abline(0, 1, col = 2)

# Note that with "smooth" extrapolation, derivative up to order 4 are continuous
# (assuming that the derivative of the original basis are continuous!) whether or not
# we reparametrise as above. With "simple" extrapolation derivative up to order K >= 2
# are continuous only if we impose the constraints that the derivatives of order 2, ..., K are zero.
# Here we check the continuity of derivatives of up to order 3:
xseq <- seq(-4, 4, length.out = 1e3) 
l0 <- wrap_basis(x = xseq)

par(mfrow = c(2, 2))
matplot(xseq, l0$X0, type = 'l') # 1st derivative w.r.t. x
matplot(xseq, l0$X1, type = 'l') # 1st derivative w.r.t. x
matplot(xseq, l0$X2, type = 'l') # 2nd derivative w.r.t. x
matplot(xseq, l0$X3, type = 'l') # 3rd derivative w.r.t. x

# Zooming in where the linearisation occurs
xseq <- seq(krange[2]-0.3, krange[2]+0.3, length.out = 1000)
l0 <- wrap_basis(x = xseq)

par(mfrow = c(2, 2))
matplot(xseq, l0$X0, type = 'l') # 1st derivative w.r.t. x
matplot(xseq, l0$X1, type = 'l') # 1st derivative w.r.t. x
matplot(xseq, l0$X2, type = 'l') # 2nd derivative w.r.t. x
matplot(xseq, l0$X3, type = 'l') # 3rd derivative w.r.t. x
abline(v = krange)

}
